#!/usr/bin/env python3
# -*- coding: utf-8 -*-
########################################################################
# Filename    : camera.py
# Description : Flask camera streaming server
# Author      : Generated by AI Assistant
# Modification: 2026/01/04
# Enhanced error handling: 2026/01/04
########################################################################
"""
Flask Camera Streaming Server

Provides MJPEG camera streaming on a dedicated port.

Requirements:
- flask
- picamera2
- opencv-python

Installation:
pip3 install flask picamera2 opencv-python

Usage:
python3 camera.py
Then visit http://raspberrypi:5000 in browser
"""

import logging
from flask import Flask, Response
from picamera2 import Picamera2
import cv2
import threading
import time
from typing import Optional, Generator

# Set up logging
logger = logging.getLogger(__name__)

app = Flask(__name__)

class CameraStream:
    """
    Handles camera capture and frame generation for streaming.
    """

    def __init__(self) -> None:
        """Initialize camera with error handling"""
        self.camera: Optional[Picamera2] = None
        self.frame: Optional[cv2.Mat] = None
        self.thread: Optional[threading.Thread] = None
        self.running = False

        try:
            self.camera = Picamera2()
            self.camera.configure(self.camera.create_video_configuration(main={"size": (640, 480)}))
            self.camera.start()
            logger.info("Camera initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize camera: {e}")
            logger.error("Make sure camera is connected and picamera2 is installed")
            raise RuntimeError("Camera initialization failed") from e

        try:
            self.running = True
            self.thread = threading.Thread(target=self._update, args=())
            self.thread.daemon = True
            self.thread.start()
            logger.info("Camera streaming thread started")
        except Exception as e:
            logger.error(f"Failed to start camera thread: {e}")
            if self.camera:
                self.camera.stop()
            raise

    def _update(self) -> None:
        """Continuously capture frames in background thread."""
        while self.running:
            try:
                if self.camera:
                    frame = self.camera.capture_array()
                    self.frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                time.sleep(0.1)
            except Exception as e:
                logger.error(f"Error capturing frame: {e}")
                time.sleep(1)  # Wait longer on error

    def get_frame(self) -> Optional[bytes]:
        """
        Get the latest frame as JPEG bytes.

        Returns:
            JPEG encoded frame bytes or None if no frame available
        """
        try:
            if self.frame is not None:
                ret, jpeg = cv2.imencode('.jpg', self.frame)
                if ret:
                    return jpeg.tobytes()
                else:
                    logger.warning("Failed to encode frame as JPEG")
                    return None
            return None
        except Exception as e:
            logger.error(f"Error getting frame: {e}")
            return None

    def stop(self) -> None:
        """Stop the camera and thread."""
        try:
            self.running = False
            if self.thread and self.thread.is_alive():
                self.thread.join(timeout=2.0)
            if self.camera:
                self.camera.stop()
                logger.info("Camera stopped successfully")
        except Exception as e:
            logger.error(f"Error stopping camera: {e}")

    def __del__(self) -> None:
        """Stop the camera when object is destroyed."""
        self.stop()

camera_stream = CameraStream()

def gen() -> Generator[bytes, None, None]:
    """Generate MJPEG frames."""
    while True:
        frame = camera_stream.get_frame()
        if frame:
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n\r\n')
        time.sleep(0.1)

@app.route('/')
def video_feed() -> Response:
    """MJPEG video feed endpoint."""
    return Response(gen(),
                    mimetype='multipart/x-mixed-replace; boundary=frame')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
