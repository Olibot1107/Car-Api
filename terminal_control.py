#!/usr/bin/env python3
# -*- coding: utf-8 -*-
########################################################################
# Filename    : terminal_control.py
# Description : Terminal-based car control with WASD keys
# Author      : Generated by AI Assistant
# Modification: 2026/01/05
########################################################################
"""
Terminal Car Control

Control the car using keyboard:
- W: Move forward (hold to continue)
- S: Move backward (hold to continue)
- A: Steer left (hold to continue turning)
- D: Steer right (hold to continue turning)
- Q: Quit and stop car

Usage:
python3 terminal_control.py
"""

import logging
import threading
import time
from pynput import keyboard
from lib.movement import CarControl

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CarController:
    def __init__(self):
        self.car = CarControl()
        self.running = True
        self.current_speed = 50  # Default speed 50%
        self.keys_pressed = set()

        # Movement states
        self.moving_forward = False
        self.moving_backward = False
        self.steering_left = False
        self.steering_right = False

        # Start control thread
        self.control_thread = threading.Thread(target=self.control_loop, daemon=True)
        self.control_thread.start()

    def control_loop(self):
        """Main control loop that runs in a separate thread"""
        while self.running:
            try:
                # Handle movement - allow simultaneous forward/backward + steering
                if self.moving_forward:
                    self.car.forward()
                    self.car.set_speed(self.current_speed)
                elif self.moving_backward:
                    self.car.backward()
                    self.car.set_speed(self.current_speed)
                else:
                    self.car.stop()

                # Handle steering (faster turning - 5 degrees per step)
                if self.steering_left:
                    # Turn left faster
                    current_angle = self.car.get_steering()
                    new_angle = max(0, current_angle - 5)
                    self.car.set_steering(new_angle)
                elif self.steering_right:
                    # Turn right faster
                    current_angle = self.car.get_steering()
                    new_angle = min(180, current_angle + 5)
                    self.car.set_steering(new_angle)
                else:
                    # Return to center faster when no steering input
                    current_angle = self.car.get_steering()
                    if current_angle < 85:
                        self.car.set_steering(min(100, current_angle + 3))
                    elif current_angle > 95:
                        self.car.set_steering(max(100, current_angle - 3))

                # Display status info
                if self.moving_forward or self.moving_backward or self.steering_left or self.steering_right:
                    direction = "Forward" if self.moving_forward else "Backward" if self.moving_backward else "Stopped"
                    steering = f"Left({self.car.get_steering()}°)" if self.steering_left else f"Right({self.car.get_steering()}°)" if self.steering_right else f"Center({self.car.get_steering()}°)"
                    print(f"\rSpeed: {self.current_speed}% | Direction: {direction} | Steering: {steering} | Camera: Pan({self.car.get_camera_pan()}°) Tilt({self.car.get_camera_tilt()}°)", end="", flush=True)

                time.sleep(0.1)  # Control loop delay

            except Exception as e:
                logger.error(f"Error in control loop: {e}")
                self.running = False

    def on_press(self, key):
        """Handle key press events"""
        try:
            if key == keyboard.KeyCode.from_char('w'):
                self.moving_forward = True
                # Allow simultaneous forward + steering
                logger.info("Moving forward")
            elif key == keyboard.KeyCode.from_char('s'):
                self.moving_backward = True
                # Allow simultaneous backward + steering
                logger.info("Moving backward")
            elif key == keyboard.KeyCode.from_char('a'):
                self.steering_left = True
                # Allow simultaneous steering + movement
                logger.info("Steering left")
            elif key == keyboard.KeyCode.from_char('d'):
                self.steering_right = True
                # Allow simultaneous steering + movement
                logger.info("Steering right")
            elif key == keyboard.KeyCode.from_char('q'):
                logger.info("Quitting...")
                self.running = False

        except Exception as e:
            logger.error(f"Error handling key press: {e}")

    def on_release(self, key):
        """Handle key release events"""
        try:
            if key == keyboard.KeyCode.from_char('w'):
                self.moving_forward = False
                logger.info("Stopped forward movement")
            elif key == keyboard.KeyCode.from_char('s'):
                self.moving_backward = False
                logger.info("Stopped backward movement")
            elif key == keyboard.KeyCode.from_char('a'):
                self.steering_left = False
                logger.info("Stopped left steering")
            elif key == keyboard.KeyCode.from_char('d'):
                self.steering_right = False
                logger.info("Stopped right steering")

        except Exception as e:
            logger.error(f"Error handling key release: {e}")

    def run(self):
        """Main run method"""
        logger.info("Starting terminal car control")
        logger.info("Controls: W=Forward, S=Backward, A=Steer Left, D=Steer Right, Q=Quit")
        logger.info("Hold keys for continuous movement/steering")

        # Center steering initially
        self.car.center_steering()
        self.car.camera_center()

        try:
            # Start keyboard listener
            with keyboard.Listener(on_press=self.on_press, on_release=self.on_release) as listener:
                while self.running:
                    listener.join(0.1)  # Check every 100ms

        except KeyboardInterrupt:
            logger.info("Interrupted by user")
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
        finally:
            # Cleanup
            self.running = False
            self.control_thread.join(timeout=1.0)
            self.car.stop()
            self.car.center_steering()
            self.car.camera_center()
            print()  # New line after status display
            logger.info("Car control stopped and cleaned up")

def main():
    """Main function"""
    controller = CarController()
    controller.run()

if __name__ == '__main__':
    main()