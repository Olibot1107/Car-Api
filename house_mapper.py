#!/usr/bin/env python3
# -*- coding: utf-8 -*-
########################################################################
# Filename    : house_mapper.py
# Description : LiDAR-based house mapping and localization app
# Author      : Generated by AI Assistant
# Modification: 2026/01/06
########################################################################
"""
House Mapping App with LiDAR

Uses LiDAR (simulated with ultrasonic) to map the house, detect walls,
and provide localization. Displays map on web interface.

Usage:
python3 house_mapper.py
"""

import time
import math
import threading
import logging
from flask import Flask, render_template, request, jsonify, Response
from flask_cors import CORS
import numpy as np
from lib.movement import CarControl

app = Flask(__name__)
CORS(app)

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global variables
car = None
mapping_thread = None
mapping_running = False

# Map parameters
MAP_SIZE = 100  # 100x100 grid
CELL_SIZE = 0.1  # 10cm per cell
MAP_CENTER = MAP_SIZE // 2

# Occupancy grid (0 = free, 1 = occupied, 0.5 = unknown)
occupancy_grid = np.full((MAP_SIZE, MAP_SIZE), 0.5, dtype=np.float32)

# Robot position and orientation
robot_x = MAP_CENTER * CELL_SIZE  # meters
robot_y = MAP_CENTER * CELL_SIZE
robot_theta = 0.0  # radians

# LiDAR parameters
LIDAR_RANGE = 4.0  # meters
LIDAR_ANGLES = np.linspace(-math.pi, math.pi, 360)  # 360 degree scan

def init_car():
    global car
    try:
        car = CarControl()
        logger.info("Car control initialized successfully")
        return True
    except Exception as e:
        logger.warning(f"Failed to initialize car hardware: {e}")
        logger.warning("Running in simulation mode - hardware controls will be disabled")
        car = None
        return False

def world_to_grid(x, y):
    """Convert world coordinates to grid coordinates"""
    grid_x = int((x / CELL_SIZE) + MAP_CENTER)
    grid_y = int((y / CELL_SIZE) + MAP_CENTER)
    return grid_x, grid_y

def grid_to_world(grid_x, grid_y):
    """Convert grid coordinates to world coordinates"""
    x = (grid_x - MAP_CENTER) * CELL_SIZE
    y = (grid_y - MAP_CENTER) * CELL_SIZE
    return x, y

def perform_lidar_scan():
    """Perform LiDAR scan using ultrasonic sensor rotated by camera servo"""
    scan_data = []
    angles_deg = np.linspace(0, 360, 36)  # 36 scans, 10 degrees each

    for angle_deg in angles_deg:
        if car:
            # Rotate camera servo to angle
            car.set_camera_pan(angle_deg)
            time.sleep(0.05)  # Wait for servo to move

            # Get distance reading
            distance_cm = car.get_distance()
            distance_m = distance_cm / 100.0  # Convert to meters

            # Convert to radians for map update
            angle_rad = math.radians(angle_deg - 180)  # Adjust for coordinate system
            scan_data.append((angle_rad, distance_m))

    # Return to center
    if car:
        car.set_camera_pan(90)

    return scan_data

def update_map(scan_data):
    """Update occupancy grid with LiDAR scan data"""
    global occupancy_grid, robot_x, robot_y, robot_theta

    for angle, distance in scan_data:
        # Calculate obstacle position
        obs_x = robot_x + distance * math.cos(angle + robot_theta)
        obs_y = robot_y + distance * math.sin(angle + robot_theta)

        # Convert to grid coordinates
        grid_x, grid_y = world_to_grid(obs_x, obs_y)

        if 0 <= grid_x < MAP_SIZE and 0 <= grid_y < MAP_SIZE:
            # Mark as occupied (wall)
            occupancy_grid[grid_x, grid_y] = 1.0

        # Mark free space along the ray
        steps = int(distance / CELL_SIZE)
        for step in range(1, steps):
            ray_x = robot_x + step * CELL_SIZE * math.cos(angle + robot_theta)
            ray_y = robot_y + step * CELL_SIZE * math.sin(angle + robot_theta)
            ray_grid_x, ray_grid_y = world_to_grid(ray_x, ray_y)
            if 0 <= ray_grid_x < MAP_SIZE and 0 <= ray_grid_y < MAP_SIZE:
                occupancy_grid[ray_grid_x, ray_grid_y] = 0.0

def mapping_loop():
    """Main mapping loop"""
    global mapping_running, robot_x, robot_y, robot_theta

    logger.info("Starting house mapping")

    while mapping_running:
        # Perform LiDAR scan with servo rotation
        scan_data = perform_lidar_scan()

        # Update map
        update_map(scan_data)

        # Move the car slowly forward
        if car:
            car.forward()
            car.set_speed(30)  # Slow speed
            time.sleep(0.5)  # Move for 0.5 seconds
            car.stop()

        # Update position estimate (dead reckoning)
        robot_x += 0.1 * math.cos(robot_theta)  # Assume moved 10cm forward
        robot_theta += 0.1  # Slight turn

        time.sleep(1.0)  # Scan every second

    logger.info("Mapping stopped")

@app.route('/')
def index():
    return render_template('mapper.html')

@app.route('/start_mapping', methods=['POST'])
def start_mapping():
    global mapping_thread, mapping_running

    if not mapping_running:
        mapping_running = True
        mapping_thread = threading.Thread(target=mapping_loop, daemon=True)
        mapping_thread.start()
        return jsonify({'success': True, 'message': 'Mapping started'})

    return jsonify({'success': False, 'message': 'Mapping already running'})

@app.route('/stop_mapping', methods=['POST'])
def stop_mapping():
    global mapping_running

    mapping_running = False
    if mapping_thread:
        mapping_thread.join(timeout=1.0)
    return jsonify({'success': True, 'message': 'Mapping stopped'})

@app.route('/get_map')
def get_map():
    """Get current map data"""
    # Convert occupancy grid to list for JSON
    grid_data = occupancy_grid.tolist()

    # Get robot position in grid coordinates
    robot_grid_x, robot_grid_y = world_to_grid(robot_x, robot_y)

    return jsonify({
        'grid': grid_data,
        'robot_x': robot_grid_x,
        'robot_y': robot_grid_y,
        'robot_theta': robot_theta,
        'map_size': MAP_SIZE
    })

@app.route('/reset_map', methods=['POST'])
def reset_map():
    global occupancy_grid, robot_x, robot_y, robot_theta

    occupancy_grid.fill(0.5)
    robot_x = MAP_CENTER * CELL_SIZE
    robot_y = MAP_CENTER * CELL_SIZE
    robot_theta = 0.0

    return jsonify({'success': True, 'message': 'Map reset'})

if __name__ == '__main__':
    init_car()
    logger.info("Starting house mapping web server on port 5001")
    app.run(host='0.0.0.0', port=5001, debug=False, threaded=True)
